* {
  margin: 0; 
  padding: 0; 
  /*To remove default browser-enforced styles, 
  we apply some default CSS values for every element in the 
  page to level the playing field all at once. */
  box-sizing: border-box; /* This is a fix that will instruct
   the browser to ignore padding in the overall width. */
}

body {
 color: #39a6b2;
 font-family: Helvetica, Arial, sans-serif;
}
 /* apply styles to <header>*/
header { 
  padding: 20px 35px; 
  /*We just told the <header> element
   to apply padding, which means to add space between where
   the <header> starts and where the content inside it 
  starts. */
  background-color: #39a6b2;
  font-weight: bold;
  display: flex; 
  /* The display: flex declaration makes
   the <header> a row by default, so there's no need to 
   explicitly declare it. And as you can see, flexbox evenly
   distributed the space of the parent element (<header>)
   among the children elements (the <h1> and <nav> links). */ 
  
  justify-content: space-between; 
  /* The justify-content property 
  only applies to elements with a display property value of flex
  or grid (more on that later). space-between: Distributes all 
  empty space evenly between child elements so they are evenly 
  spaced apart. */
  
  flex-wrap: wrap; 
  /* flex-wrap, tells the container that when 
  its child elements can't fit on one line, let them break onto
  the next line. The flex-wrap property, allows the flexbox 
  container to let its children wrap onto the next line. By
   default, the value of flex-wrap is set to none, so we need
    to explicitly tell it to be wrap */
}
 
header h1 {
 font-weight: bold;
 font-size: 36px;
 color: #fce138;
 margin: 0;
}

header a {
  text-decoration: none;
  color: #fce138;
}

header nav { 
  margin: 7px 0;
}

header nav ul {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center; /* The property align-items works
like justify-content but on the opposite axis. To "justify"
information means to position it on the main axis, but to
"align" it means to position it along the cross axis. In this
case, we're vertically centering our content in the <nav> element.
When using a flexbox as a row, the horizontal (x) axis is known
as the main axis. This is the direction we can control when
laying out the flexbox children. The vertical (y) axis is the
cross axis. If we were to use the flex-direction property and set
the value to be column instead of row (the default value), those
axes would be switched and the values used for justify-content
and align-items would be applied differently. This is because
justify always follows along the main axis and align always
follows along the cross axis. */
list-style: none;
}

header nav ul li a {
  padding: 10px 15px;
  font-weight: lighter;
  font-size: 1.55vw; /* By setting the value to 1.55vw, we're
telling the browser that the font's size should be roughly 1.55
percent of the window's overall width. This means that if the
browser grows or shrinks, that size will change relative to the
new overall width. */ 
}

/* Hero style begins. */

.hero {
  display: flex;
  flex-wrap: wrap;
  justify-content: center; /*We set justify-content to center 
  because want these two boxes as close to the middle of the 
  screen as possible. */
  background-image: url("../images/hero-bg.jpg");
  align-items: flex-start;
  padding: 60px;
  background-size: cover; /*background-size can set the 
  size of the background image to its original size or 
  make it stretched, repeated, or constrained to fit 
  the available space. In our case, the cover assignment 
  will shrink the image so that parts 
  of it won't get clipped. */
}

.hero-cta {
  width: 35%;
  text-align: right;
  margin: 3.5%;
  color: #fff;
  font-size: 18px;
  line-height: 1.2;
}

.hero-cta h2 {
  font-style: italic;
  font-size: 55px;
  color: #fce138;
}

.hero-form {
  border: 3px solid #024e76; /* Similar to how padding 
  values were assigned in the last lesson, the border 
  property can be declared with a single value that 
  represents one value for all four sides. The border 
  property can also be designated for each side: border-top,
  border-bottom, border-left, border-right. Unlike padding, 
  border can also have style and color values declared in 
  addition to width. */
  background-color: #ffde08;
  padding: 20px; /* padding: Creates an inner margin within 
  the border. */
  color: #024e76;
  width: 40%;
  margin: 3.5%; /* We used percentage values for the margins
   and widths this time around to show how it can work in the
   overall flow of this section.*/
}

 .hero-form h3 {
   font-size: 24px;
   margin: 0;
 }

.hero-form p {
margin: 5px 0 15px 0;
}

.form-input {
  border: 1px solid #024e76; 
  /* A skinny 1px border helped 
  emphasize our sign-up requests. */
  display: block;
  /*This property instructs the browser
   to render the element either as a 
   <block> or inline. Some other <block> 
   elements we've used are: <p>, >div>, and
   all the >h1> to >h6>. 
   Some inline elements we've used are:
   <span>, <a>, and <label> */
  padding: 7px 15px;
  font-size: 16px;
  color: #024e76;
  width: 100%;
  margin-bottom: 15px;
}

.hero-form label { /* Adding some horizontal spacing for 
the <label> element in the radio button 
elements helps the user not misinterpret 
which selection is for which answer. */
  margin: 0 5px;
} 

.hero-form button {
  background-color:#024e76;
  color: #fce138;
  padding: 10px 20px;
  font-size: 16px;
  font-weight: bold;
}
/* HERO STYLES END */

.intro p {
  line-height: 1.6;
  color: #39a6b2;
  width: 80%;
  font-size: 20px;
  margin: 0 auto;
  text-align: center;
}
/* Because we shrunk the width of the paragraph down to 80%,
it no longer looks centered. Only the text inside is 
centered. We could use our handy display: inline-block;
trick to fix it, but there's another common tactic for 
centering a block element with a width of less than 100%: 
margin: 0 auto; This is shorthand for setting a top and
bottom margin of zero and a left and right margin of auto.
what does "auto" mean? This essentially tells the browser 
to calculate the margins for us. When the browser is asked 
to do this on both sides of an element, it will do its best
to make them even, thus pushing the element into the center.
Note that this only works for horizontal centering.
margin: auto 0 does not vertically center elements. */


.section-title {
   font-size: 48px;
   color: #024e76;
   padding-bottom: 20px;
   text-align: center;
   margin: 0 auto 35px auto;
   width: 50%;
   border-color: #fce138;
   border-bottom: 3px solid;
 
}
.primary-border {
     border-color: #fce138;
}
   
.secondary-border {
     border-color: #39a6b2;
}

.steps {
  background: #f5d504;
}

.step {
  flex-wrap: wrap;
  margin: 50px auto;
  padding-bottom: 50px;
  width: 80%;
  border-bottom: 1px solid #39a6b2;
  display: flex;  
  align-items: center;
  justify-content: space-between;
}

.step h3 {
  color: #024e76;
  font-size: 46px;
  flex: 1 30%; 
  /*.step h3 will be at least 30% 
  wide and will receive any extra
  space in the container. */
}

.step-info {
  flex: 2 70%;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
} /* .step-info will be at least 70% wide,
 but will receive any extra space in the
 container at a 2-to-1 ratio, meaning it
 will receive 2 more units of unused
 space than a sibling with a flex-grow
 value of 1. 
 */

.step-img {
  flex: 1 12%;
  margin-right: 20px;
}

.step-img img {
  max-width: 100%;
}
/* we need to do is tell the <img> element
to limit its width to be whatever its container is.
*/

.step-text p {
  font-size: 14px;
}

.step-text {
  flex: 12; 
}
/* Now both child elements have a flex-grow
property of 1 and 12, respectively. This means
that  .step-text will be allotted 12 times more
unused space than .step-img, but .step-img
at the very least must be 12 percent of the
width of .step-info. */

.step-text h4 {
  font-size: 26px;
  line-height: 1.5;
  color: #024e76;
}

.step p {
  color: #39a6b2;
  font-size: 23px;
}

.trainers {
  width: 100%;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-around;
}

.trainer {
  margin: 15px;
  background: #024e76;
  color: #fce138;
  flex: 1; 
  /* If all flexbox children have a value of
  flex: 1, that means they will share any extra
  space evenly. */
}

.trainer img {
  width: 100%;
}
  

.trainer-bio {
  padding: 25px;
  line-height: 1.3;
}

.trainer-bio h3 {
   font-size: 28px;
}

 .trainer-bio h4 {
   font-weight: lighter;
   font-size: 22px;
   margin-bottom: 15px;
}

 .trainer-bio p {
   font-size: 17px;   
}

.trainer-role {
  color: rgb(51, 3, 3);
  font-weight: bold;
}
 /* END MEET THE TRAINERS SECTION */


 /* REACH OUT STYLES START */

 .contact {
   background-color: #024e76;
}

 .contact h2 {
   color: #fce138;
}

.contact-info {
  display: flex;
  justify-content: space-between;
  flex-wrap: wrap;
}

.contact-info > * */ {
  flex: 1;
  margin: 15px;
} /*Here, the * selector is saying
  "select all elements that are direct children of 
  anything with a class of contact-info." The > symbol
  means it's looking specifically for direct children of
  the element listed first. In this case, it's selecting
  all children of the element with contact-info as its class.
  In this case, it will apply the above styles to the three
  flexbox child elements in our contact-info flexbox container,
  so we are now all set with this section's flexbox layout. */

.contact-info iframe {
  height: 400px;
}

.contact-info div {
  color: rgb(212, 209, 209);
}

.contact-info h3 {
  color: #fce138;
  font-size: 32px;
}

.contact-info p, .contact-info address {
/* Note that the second CSS rule targets two different 
elements. The comma separates the two selectors, indicating
that the subsequent declaration block will apply to both CSS
selectors. */
  margin: 20px 0;
  line-height: 1.5;
  font-size: 16px;
  font-style: normal;
}

.contact-form input, .contact-form textarea {
  border: 1px solid #024e76;
  display: block;
  padding: 7px 15px;
  font-size: 16px;
  color: #747602;
  width: 100%;
  margin-bottom: 15px;
  margin-top: 5px;
}

.contact-form button {
  width: 100%;
  border: none;
  background: #a80000;
  color: #eeff00;
  text-align: center;
  padding: 15px 0;
  font-size: 16px;
}

.contact-info a {
  color: #38fcfc;
}

/* REACH OT STILES END */

 footer {
  display: flex;
  justify-content: space-between;
  flex-wrap: wrap;
  background: #f5d504;
  width: 100%;
  padding: 40px 35px;
}

footer h2 {

  color: #024e76;
  font-size: 30px;
}

.SVS:hover {
  color: rgb(240, 6, 6);
  font-style: italic;
}

footer div {
 
  line-height: 1.5; /* This assigns how much vertical space
   should be between lines of text content. */
  text-align: right; /* This lets us align our text to the 
  left, right, center, or justified. By default, 
  it is left-aligned. */
}

footer a {
  color: #024e76;
}

section {
  padding: 60px;
}

.text-left {
  text-align: left;
}

.text-right {
  text-align: right;
}
/* CSS classes like the two above, that are not specific to 
 any part of an HTML document and that do only one thing are
 what's known as a utility classes. The idea behind them is
 instead of creating very specific classes that only fit the
 needs of a couple of HTML elements, you create more CSS 
 classes that apply one property declaration and are applied
 by adding multiple classes to an HTML element instead. */

 .flex-row {
   display: flex; /* The default flex-direction value for a 
   flexbox is row, so we do not need to explicitly declare it. */
 }

 /* MEDIA QUERY FOR SMALLER DESKTOP SCREENS AND SMALLER */
@media screen and (max-width: 980px) {
  header {
    padding-bottom: 0;
    justify-content: center;
  }

.hero-cta, .hero-form {
  width: 100%;
}

.hero-cta {
  text-align: center;
}

.section-title {
  width: 80%;
} /* We made some adjustments to all of the
.section-titles to make them wider on a smaller
screen so they don't get too narrow. */

.trainer {
  flex: 0 70%;
} /* We didn't want the cards to run too narrow as 
the screen shrank, but we also didn't want them to 
be completely full width because they'd be way too big.
So we made them just wide enough that they had to be 
on their own line. For that, we used flex: 0 70%. */

.contact-info iframe {
  flex: 1 100%;
}

  header h1 {
    width: 100%;
    text-align: center;
  }

  header nav ul {
    margin-top: 20px;
    width: 100%;
    justify-content: center;
  }

  header nav ul li a {
    font-size: 20px;
  }

  footer h2, footer div {
    text-align: center;
    width: 100%;
  }
}

/* MEDIA QUERY FOR TABLETS AND SMALLER */
@media screen and (max-width: 768px) {
  header h1 {
    /* this will be applied on any screen between 768px and 575px */
    font-size: 80px;
  }

  section {
    padding: 30px 15px;
  }

  .step h3 {
    flex: 1 100%;
    text-align: center;
  }

  .step-info {
    flex: 2 100%;
    text-align: center;
    justify-content: center;
  }

  .step-img {
    flex: 0 32px;
    margin-right: 0;
    margin-top: 15px;
    margin-bottom: 15px;
  }

  .step-text {
    flex: 100%;
  }
}

/* MEDIA QUERY FOR MOBILE PHONES AND SMALLER */
@media screen and (max-width: 575px) {
  header h1 {
    /* this will be applied on any screen smaller than 575px */
    font-size: 100px;
  }

  .hero-form button {
    width: 100%;
  }

  .section-title {
    width: 95%;
  }

  .intro p {
    width: 100%;
  }

  .trainer {
    flex: 0 100%;
  }

  .contact-info {
    text-align: center;
  }

  .contact-info > * {
    flex: 0 100%;
  }

  .contact-form {
    order: 3;
  } /* The order property can be used to rearrange
 how child elements appear on a page without actually
 moving the HTML code aroundâ€”it can be extremely useful
 in cases like this. */
}