* {
  margin: 0; 
  padding: 0; /*To remove default browser-enforced styles, 
  we apply some default CSS values for every element in the 
  page to level the playing field all at once. */
  box-sizing: border-box; /* This is a fix that will instruct
   the browser to ignore padding in the overall width. */
}

body {
 color: #39a6b2;
 font-family: Helvetica, Arial, sans-serif;
}
 /* apply styles to <header>*/
header { 
  padding: 20px 35px; /*We just told the <header> element
   to apply padding, which means to add space between where
   the <header> starts and where the content inside it 
  starts. */
  background-color: #39a6b2;
  font-weight: bold;
  display: flex; /* The display: flex declaration makes
   the <header> a row by default, so there's no need to 
   explicitly declare it. And as you can see, flexbox evenly
   distributed the space of the parent element (<header>)
   among the children elements (the <h1> and <nav> links). */ 
  
  justify-content: space-between; /* The justify-content property 
  only applies to elements with a display property value of flex
  or grid (more on that later). space-between: Distributes all 
  empty space evenly between child elements so they are evenly 
  spaced apart. */
  
  flex-wrap: wrap; /* flex-wrap, tells the container that when 
  its child elements can't fit on one line, let them break onto
  the next line. The flex-wrap property, allows the flexbox 
  container to let its children wrap onto the next line. By
   default, the value of flex-wrap is set to none, so we need
    to explicitly tell it to be wrap */
}
 
header h1 {
 font-weight: bold;
 font-size: 36px;
 color: #fce138;
 margin: 0;
}

header a {
  text-decoration: none;
  color: #fce138;
}

header nav { 
  margin: 7px 0;
}

header nav ul {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center; /* The property align-items works
like justify-content but on the opposite axis. To "justify"
information means to position it on the main axis, but to
"align" it means to position it along the cross axis. In this
case, we're vertically centering our content in the <nav> element.
When using a flexbox as a row, the horizontal (x) axis is known
as the main axis. This is the direction we can control when
laying out the flexbox children. The vertical (y) axis is the
cross axis. If we were to use the flex-direction property and set
the value to be column instead of row (the default value), those
axes would be switched and the values used for justify-content
and align-items would be applied differently. This is because
justify always follows along the main axis and align always
follows along the cross axis. */
list-style: none;
}

header nav ul li a {
  margin: 0 30px;
  font-weight: lighter;
  font-size: 1.55vw; /* By setting the value to 1.55vw, we're
telling the browser that the font's size should be roughly 1.55
percent of the window's overall width. This means that if the
browser grows or shrinks, that size will change relative to the
new overall width. */ 
}

/* Hero style begins. */

.hero {
  display: flex;
  flex-wrap: wrap;
  justify-content: center; /*We set justify-content to center 
  because want these two boxes as close to the middle of the 
  screen as possible. */
  background-image: url("../images/hero-bg.jpg");
  padding: 60px;
  background-size: cover; /*background-size can set the 
  size of the background image to its original size or 
  make it stretched, repeated, or constrained to fit 
  the available space. In our case, the cover assignment 
  will shrink the image so that parts 
  of it won't get clipped. */
}

.hero-cta {
  width: 35%;
  text-align: right;
  margin: 3.5%;
  color: #fff;
  font-size: 18px;
  line-height: 1.3;
}

.hero-cta h2 {
  font-style: italic;
  font-size: 55px;
  color: #fce138;
}

.hero-form {
  border: 3px solid #024e76; /* Similar to how padding 
  values were assigned in the last lesson, the border 
  property can be declared with a single value that 
  represents one value for all four sides. The border 
  property can also be designated for each side: border-top,
  border-bottom, border-left, border-right. Unlike padding, 
  border can also have style and color values declared in 
  addition to width. */
  background-color: #ffde08;
  padding: 20px; /* padding: Creates an inner margin within 
  the border. */
  color: #024e76;
  width: 40%;
  margin: 3.5%; /* We used percentage values for the margins
   and widths this time around to show how it can work in the
   overall flow of this section.*/
}

 .hero-form h3 {
   font-size: 24px;
   margin: 0;
 }

.hero-form p {
margin: 5px 0 15px 0;
}

.form-input {
  border: 1px solid #024e76; 
  /* A skinny 1px border helped 
  emphasize our sign-up requests. */
  display: block;
  /*This property instructs the browser
   to render the element either as a 
   <block> or inline. Some other <block> 
   elements we've used are: <p>, >div>, and
   all the >h1> to >h6>. 
   Some inline elements we've used are:
   <span>, <a>, and <label> */
  padding: 7px 15px;
  font-size: 16px;
  color: #024e76;
  width: 100%;
  margin-bottom: 15px;
}

.hero-form label { /* Adding some horizontal spacing for 
the <label> element in the radio button 
elements helps the user not misinterpret 
which selection is for which answer. */
  margin: 0 5px;
} 

.hero-form button {
  background-color:#024e76;
  color: #fce138;
  padding: 10px 20px;
  font-size: 16px;
  font-weight: bold;
}
/* HERO STYLES END */

.intro p {
  line-height: 1.6;
  color: #39a6b2;
  width: 80%;
  font-size: 20px;
  margin: 0 auto;
  text-align: center;
}
/* Because we shrunk the width of the paragraph down to 80%,
it no longer looks centered. Only the text inside is 
centered. We could use our handy display: inline-block;
trick to fix it, but there's another common tactic for 
centering a block element with a width of less than 100%: 
margin: 0 auto; This is shorthand for setting a top and
bottom margin of zero and a left and right margin of auto.
what does "auto" mean? This essentially tells the browser 
to calculate the margins for us. When the browser is asked 
to do this on both sides of an element, it will do its best
to make them even, thus pushing the element into the center.
Note that this only works for horizontal centering.
margin: auto 0 does not vertically center elements. */


.section-title {
   font-size: 55px;
   color: #024e76;
   padding-bottom: 20px;
   text-align: center;
   margin: 0 auto 35px auto;
   width: 50%;
   border-color: #fce138;
   border-bottom: 3px solid;
 
}
.primary-border {
     border-color: #fce138;
}
   
.secondary-border {
     border-color: #39a6b2;
}

.steps {
  background: #f5d504;
}

.step {
  margin: 50px auto;
  padding-bottom: 50px;
  width: 80%;
  border-bottom: 1px solid #39a6b2;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
}

.step h3 {
  color: #024e76;
  font-size: 46px;
  flex: 1 30%;
}

.step-img {
  flex: 1 12%;
  margin-right: 20px;
}

.step-img img {
  max-width: 100%;
}

.step-text {
  flex: 12; /*This means that .step-text will be
  allotted 12 times more unused space than
  .step-img, but .step-img at the very least
  must be 12 percent of the width of .step-info. */
}

.step-text h4 {
  font-size: 26px;
  line-height: 1.5;
  color: #024e76;
}

.step-info {
  flex: 2 70%;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
}

.step p {
  color: #39a6b2;
  font-size: 23px;
}

.trainers {
  width: 100%;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-around;
}

.trainer {
  margin: 15px;
  background: #024e76;
  color: #fce138;
  flex: 1; /* If all flexbox children have a value of
           flex: 1, that means they will share any extra
           space evenly. */
}

.trainer img {
  width: 100%;
}
  

.trainer-bio {
  padding: 25px;
  line-height: 1.3;
}

.trainer-bio h3 {
   font-size: 28px;
}

 .trainer-bio h4 {
   font-weight: lighter;
   font-size: 22px;
   margin-bottom: 15px;
}

 .trainer-bio p {
   font-size: 17px;   
}
 /* END MEET THE TRAINERS SECTION */


 /* REACH OUT STYLES START */

 .contact {
   background-color: #024e76;
}

 .contact h2 {
   color: #fce138;
}

.contact-info iframe {
  width: 400px;
  height: 400px;
}

.contact-info div {
  width: 410px;
  display: inline-block; /* Note that in the CSS rule above
  targeting the child <div>, we overwrote the default display
  property for a <div> and changed it from block to
  inline-block. This allows the .contact-info container to
  sit on the same row as the <iframe> element and allows us
  to assign a width, something that the property value inline
  would not let us do. */
  vertical-align: top; /* Because the content of this <div>
  naturally rests at the bottom of the container, we need the
  vertical-align property to lift this content up to the top.
  In conjunction with the text-align property, this allows 
  the contact information to begin at the top of the <div> 
  and start aligned from the left for an easy-to-read layout.
  */
  text-align: left;
  margin: 30px 0 0 60px;
  color: rgb(212, 209, 209);
}

.contact-info h3 {
  color: #fce138;
  font-size: 32px;
}

.contact-info p, .contact-info address {
/* Note that the second CSS rule targets two different 
elements. The comma separates the two selectors, indicating
that the subsequent declaration block will apply to both CSS
selectors. */
  margin: 20px 0;
  line-height: 1.5;
  font-size: 20px;
  font-style: normal;
}

.contact-info a {
  color: #38fcfc;
}

/* REACH OT STILES END */

 footer {
  display: flex;
  justify-content: space-between;
  flex-wrap: wrap;
  background: #f5d504;
  width: 100%;
  padding: 40px 35px;
}

footer h2 {

  color: #024e76;
  font-size: 30px;
}

.SVS:hover {
  color: rgb(240, 6, 6);
  font-style: italic;
}

footer div {
 
  line-height: 1.5; /* This assigns how much vertical space
   should be between lines of text content. */
  text-align: right; /* This lets us align our text to the 
  left, right, center, or justified. By default, 
  it is left-aligned. */
}

footer a {
  color: #024e76;
}

section {
  padding: 60px;
}

.text-left {
  text-align: left;
}

.text-right {
  text-align: right;
}
/* CSS classes like the two above, that are not specific to 
 any part of an HTML document and that do only one thing are
 what's known as a utility classes. The idea behind them is
 instead of creating very specific classes that only fit the
 needs of a couple of HTML elements, you create more CSS 
 classes that apply one property declaration and are applied
 by adding multiple classes to an HTML element instead. */

 .flex-row {
   display: flex; /* The default flex-direction value for a 
   flexbox is row, so we do not need to explicitly declare it. */
 }