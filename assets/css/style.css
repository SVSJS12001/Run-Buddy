* {
  margin: 0; 
  padding: 0; /*To remove default browser-enforced styles, 
  we apply some default CSS values for every element in the 
  page to level the playing field all at once. */
  box-sizing: border-box; /* This is a fix that will instruct
   the browser to ignore padding in the overall width. */
}


body {
  color: #39a6b2;
  font-family: Helvetica, Arial, sans-serif;
}

header { 
  padding: 20px 35px;
  background-color: #39a6b2;
  font-weight: bold;
}
  /* apply styles to <header>
We just told the <header> element to apply 
padding, which means to add space between 
where the <header> starts and where the content 
inside it starts. We also applied a background-color 
of a light blue / teal.
*/
 
header h1 {
 font-weight: bold;
 font-size: 36px;
 color: #fce138;
 margin: 0;
 display: inline; /* So just by adding that one 
 property declaration (display: inline;) and setting 
 the <h1> to inline instead of block, we moved the <nav> 
 on the righthand side up. */
}

header a {
  text-decoration: none;
  color: #fce138;
}

header nav { 
  float: right;
  margin: 7px 0;
}
  /* float: Think of this as similar to the 
  text-wrapping property in Microsoft Word, 
  which takes elements that want to take up 100% 
  of its parent's width by default (known in CSS 
  as block elements) and pushes everything after 
  it below it—even if it physically isn't 100% of 
  its parents width—and allows other elements to 
  come along side of it or wrap around it (known in 
  CSS as inline elements). This property is used when 
  we have HTML elements that would look better side by 
  side, and we want to use our horizontal space in a more 
  meaningful way. */


header nav ul li {
  display: inline;
}

header nav ul li a {
  margin: 0 30px;
  font-weight: lighter;
  font-size: 22px;
}

/* Hero style begins. */

.hero {
  background-image: url("../images/hero-bg.jpg");
  height: 600px; 
  padding: 60px;
  background-size: cover; /*background-size can set the 
  size of the background image to its original size or 
  make it stretched, repeated, or constrained to fit 
  the available space. In our case, the cover assignment 
  will shrink the image so that parts 
  of it won't get clipped. */
  background-position: center; /* Background-position can
  move the initial position of the background image. 
  We'll set this position to center. */
  position: relative;
}

.hero-form {
  border: 3px solid #024e76;
  background-color: #ffde08;
  padding: 20px; /* padding: Creates an inner margin within 
  the border. */
  width: 500px; 
  color: #024e76;
  /* Similar to how padding values were assigned in 
  the last lesson, the border property can be declared
  with a single value that represents one value for all
  four sides. The border property can also be designated 
  for each side: border-top, border-bottom, border-left, 
  border-right. Unlike padding, border can also have style
  and color values declared in addition to width. */
  position: absolute;
  bottom: 120px;
  right: 140px;
 }

 .hero-form h3 {
   font-size: 24px;
   margin: 0;
 }

.hero-form p {
margin: 5px 0 15px 0;
}

.form-input {
  border: 1px solid #024e76; 
  /* A skinny 1px border helped 
  emphasize our sign-up requests. */
  display: block;
  /*This property instructs the browser
   to render the element either as a 
   <block> or inline. Some other <block> 
   elements we've used are: <p>, >div>, and
   all the >h1> to >h6>. 
   Some inline elements we've used are:
   <span>, <a>, and <label> */
  padding: 7px 15px;
  font-size: 16px;
  color: #024e76;
  width: 100%;
  margin-bottom: 15px;
}

.hero-form label { /* Adding some horizontal spacing for 
the <label> element in the radio button 
elements helps the user not misinterpret 
which selection is for which answer. */
  margin: 0 5px;
} 

.hero-form button {
  background-color:#024e76;
  color: #fce138;
  padding: 10px 20px;
  font-size: 16px;
  font-weight: bold;
}
/* HERO STYLES END */

.intro {
  text-align: center;
}

.intro p {
  line-height: 1.6;
  color: #39a6b2;
  width: 80%;
  font-size: 20px;
  margin: 0 auto;
}
/* Because we shrunk the width of the paragraph down to 80%,
it no longer looks centered. Only the text inside is 
centered. We could use our handy display: inline-block;
trick to fix it, but there's another common tactic for 
centering a block element with a width of less than 100%: 
margin: 0 auto; This is shorthand for setting a top and
bottom margin of zero and a left and right margin of auto.
what does "auto" mean? This essentially tells the browser 
to calculate the margins for us. When the browser is asked 
to do this on both sides of an element, it will do its best
to make them even, thus pushing the element into the center.
Note that this only works for horizontal centering.
margin: auto 0 does not vertically center elements. */


.section-title {
   font-size: 55px;
   color: #024e76;
   margin-bottom: 35px;
   padding: 0 100px 20px 100px;
   border-color: #fce138;
   border-bottom: 3px solid;
   display: inline-block; 
  }
   /* Block elements take up 100% of the width of their 
   parent, regardless of content size. Inline elements only 
   take up as much space as their content needs, which means
   multiple inline elements can sit next to each other.
   The <h2> element, by default, is a block element, which 
   means the styling associated with it is extending to 
   fill up 100% of the width of the parent container. 
   Using CSS, we can change that default behavior. We chose 
   to use the inline-block value instead of the inline value 
   so it can have the best of both worlds. It's now an inline 
   element, but things like padding still behave like they
   would on block elements. Coupled with our text-align 
   property from before, we now have a center-aligned heading
   with an appropriately sized border: */

.primary-border {
     border-color: #fce138;
   }
   
.secondary-border {
     border-color: #39a6b2;
   }


.steps {
  text-align: center;
  background: #f5d504;
}

.steps div {
  margin-bottom: 80px;
}

.steps img {
  width: 15%;
}

.steps h3 {
  color: #024e76;
  font-size: 46px;
  margin-top: 10px;
}

.steps p {
  color: #39a6b2;
  font-size: 23px;
}

.steps span {
  font-size: 38px;
}

.trainers {
  text-align: center;
 /* By adding that to the entire <section> element 
with a class attribute of "trainers", our <h2> element 
that says "Meet the Trainers" should now be centered. */
}

.trainer {
  width: 900px; /* We don't want the content to span 
  the full width of the page because it will run a little 
  too long, so we've given it a set width value of 900px. */
  margin: 0 auto 30px auto; /* This is shortahnd for:
  margin-top: 0, margin-right: auto, margin-bottom:30px, and
  margin-left: auto.
  By using auto as the values 
  for the left and right margin, we're telling the browser 
  to take whatever space is unused and evenly distribute it 
  on those sides, centering the element. An example of this 
  would be if we had a screen that was 1000 pixels wide and 
  an element that was only 800 pixels wide, the unused space 
  would be 200 pixels; and if both left and right margins 
  were set to auto, each side would get 100 pixels applied 
  to it. 
  Lastly, we provided some spacing below it so the next 
  trainers don't run up against one another. */
  background: #024e76;
  color: #fce138;
  overflow: auto;;
}

.trainer img {
  width: 35%;
  float: left; 
} /* In this case, we floated both elements
  (the <img> and <div>), which means its parent element—the
  <article> element—cannot interpret how much space its 
  inner HTML content needs and assumes there's nothing 
  inside it at all. This means the <article> element's 
  styles, like background-color, don't show up because 
  the <article> element itself is 0 pixels tall. The 
  overflow fix we applied ".trainer" told the trainer's 
  <article> element that it does in fact have content inside
  of it and that it needs to look for it and account for 
  those two floated HTML elements' sizes. This is what's 
  known as providing block formatting context to the element.
*/

.trainer-bio {
  padding: 35px;
  float: left;
  width: 65%;
}

.text-left {
  text-align: left;
}

.text-right {
  text-align: right;
}
/* CSS classes like the two above, that are not specific to 
 any part of an HTML document and that do only one thing are
 what's known as a utility classes. The idea behind them is
 instead of creating very specific classes that only fit the
 needs of a couple of HTML elements, you create more CSS 
 classes that apply one property declaration and are applied
 by adding multiple classes to an HTML element instead. */

 .trainer-bio h3 {
   font-size: 32px;
   margin-bottom: 8px;
 }

 .trainer-bio h4 {
   font-weight: lighter;
   font-size: 26px;
   margin-bottom: 25px;
 }

 .trainer p {
   font-size: 17px;
   line-height: 1.3;
 }
 /* END MEET THE TRAINERS SECTION */

 footer {
  background: #f5d504;
  width: 100%;
  padding: 40px 35px;
}

footer h2 {
  display: inline; /* same (display inline) property 
  as in the heafer h1 */
  color: #024e76;
  font-size: 30px;
  margin: 0;
}

.SVS:hover {
  color: rgb(240, 6, 6);
  font-style: italic;
}

footer div {
  float: right;
  line-height: 1.5; /* This assigns how much vertical space
   should be between lines of text content. */
  text-align: right; /* This lets us align our text to the 
  left, right, center, or justified. By default, 
  it is left-aligned. */
}

footer a {
  color: #024e76;
}

section {
  padding: 60px;
}